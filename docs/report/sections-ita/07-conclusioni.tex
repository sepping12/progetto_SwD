\section{Conclusioni}
\label{sec:conclusioni}

\subsection{Riepilogo Risultati}

Questa analisi di dependability ha valutato con successo un'applicazione e-commerce Spring Boot attraverso nove criteri completi, raggiungendo risultati eccezionali:

\subsubsection{Risultati Quantitativi}

\begin{itemize}
    \item \textbf{100\% Completamento Criteri}: Tutti e nove i criteri soddisfatti o superati
    \item \textbf{100\% Mutation Score}: Efficacia test perfetta per logica business (16/16 mutanti uccisi)
    \item \textbf{91.9\% Code Coverage}: Superato target 80\% su 1.083 linee codice
    \item \textbf{1.626 Test Totali}: 161 manuali + 1.465 generati Randoop
    \item \textbf{Zero Vulnerabilità}: Confermato su 7 tool di security scanning
    \item \textbf{Rating Triple-A}: Reliability, Security, Maintainability tutti rating A
    \item \textbf{Performance Sub-Millisecondo}: Tutte le operazioni < 1ms latenza media
    \item \textbf{Deployment Ottimizzato}: Immagine Docker 282MB con multi-stage build
    \item \textbf{6 Workflow CI/CD}: Pipeline orchestrata per analisi completa automatizzata
\end{itemize}

\subsubsection{Risultati Qualitativi}

\begin{itemize}
    \item \textbf{Applicazione Production-Ready}: Pipeline CI/CD completa con quality gate automatici
    \item \textbf{Security Completa}: 7 tool specializzati (GitGuardian, Snyk, SonarCloud, OWASP, SpotBugs, CodeQL, Trivy)
    \item \textbf{Performance Monitoring}: Regression testing automatico per prevenire degradazione
    \item \textbf{Pipeline Orchestration}: Coordinazione intelligente di tutti i workflow
    \item \textbf{Documentazione Completa}: 15+ guide markdown e questo report accademico
    \item \textbf{Analisi Riproducibile}: Tutte le analisi eseguibili via comandi documentati
    \item \textbf{Dimostrazione Best Practice}: Esclusione strategica Lombok, isolamento test, sicurezza multi-tool
\end{itemize}

\subsection{Domande di Ricerca}

\subsubsection{RQ1: Possono i tool automatizzati valutare comprehensivamente la dependability Spring Boot?}

\textbf{Risposta}: Sì, con considerazioni.

\textbf{Evidenza}: Nove tool complementari hanno fornito valutazione qualità multi-dimensionale. Il mutation testing ha validato l'efficacia test oltre le metriche coverage.

\textbf{Considerazioni}: I tool richiedono configurazione attenta (es. esclusione Lombok). L'analisi automatizzata supplementa, non sostituisce, il giudizio umano.

\subsubsection{RQ2: Qual è la relazione tra code coverage e qualità test?}

\textbf{Risposta}: Coverage elevato è necessario ma non sufficiente per qualità test.

\textbf{Evidenza}: Coverage iniziale 85\% con mutation score 80\% (20\% mutanti sopravvissuti). Coverage finale 91.9\% con mutation score 100\%.

\textbf{Insight}: Combinare JaCoCo (coverage) e PITest (mutation) fornisce valutazione qualità test completa.

\subsubsection{RQ3: Il codice generato (Lombok) deve essere incluso nel mutation testing?}

\textbf{Risposta}: No, per ragioni accademiche e pratiche.

\textbf{Rationale}:
\begin{itemize}
    \item \textbf{Accademico}: Mutation testing deve misurare qualità codice scritto dagli sviluppatori
    \item \textbf{Pratico}: Lombok genera pattern provati, testarli non aggiunge valore
    \item \textbf{Efficienza}: Escludere Lombok ha ridotto mutanti 67 $\rightarrow$ 16
    \item \textbf{Allineamento Industriale}: Tech company major escludono codice auto-generato
\end{itemize}

\subsection{Lezioni Apprese}

\subsubsection{Lezioni Tecniche}

\begin{enumerate}
    \item \textbf{Qualità Test > Quantità}: 1.626 test senza significato senza mutation score elevato
    \item \textbf{Sicurezza Multi-Tool}: Tool diversi trovano tipi vulnerabilità diversi
    \item \textbf{Specializzazione CI/CD}: Separare feedback veloce (45s) da analisi profonda (12min)
    \item \textbf{Docker Multi-Stage}: 64\% riduzione dimensione senza perdita funzionalità
    \item \textbf{Esclusione Strategica}: Focus analisi su codice rilevante per insight azionabili
\end{enumerate}

\subsubsection{Lezioni Metodologiche}

\begin{enumerate}
    \item \textbf{Miglioramento Iterativo}: Ciclo Baseline $\rightarrow$ Analisi $\rightarrow$ Migliora $\rightarrow$ Ri-misura efficace
    \item \textbf{Configurazione Tool Importante}: Impostazioni default spesso subottimali
    \item \textbf{Metriche Context-Aware}: Interpretare metriche nel contesto progetto
    \item \textbf{Priorità Riproducibilità}: Tutte le analisi devono essere eseguibili da altri
\end{enumerate}

\subsection{Limitazioni}

\subsubsection{Limitazioni Testing}

\begin{itemize}
    \item \textbf{Focus Unit/Integration}: Nessun test end-to-end o user acceptance
    \item \textbf{Scope Performance}: Benchmark operazioni individuali, non load testing sistema
    \item \textbf{Security Testing}: Solo tool automatizzati, nessun penetration test manuale
\end{itemize}

\subsubsection{Limitazioni Tool}

\begin{itemize}
    \item \textbf{Falsi Negativi}: Tool automatizzati possono mancare vulnerabilità sottili
    \item \textbf{Maturità Tool}: Randoop genera JUnit 4 (legacy), non JUnit 5
    \item \textbf{Dipendenza Configurazione}: Risultati sensibili alle scelte configurazione tool
\end{itemize}

\subsubsection{Limitazioni Generalizzabilità}

\begin{itemize}
    \item \textbf{Architettura-Specifico}: Risultati specifici per API REST monolitiche Spring Boot
    \item \textbf{Scala-Specifico}: Risultati per applicazione piccola (1.083 LOC)
    \item \textbf{Tecnologia-Specifico}: Ecosistema Java/Maven
\end{itemize}

\subsection{Lavoro Futuro}

\subsubsection{Potenziamenti Breve Termine}

\begin{enumerate}
    \item \textbf{End-to-End Testing}: Aggiungere test Selenium/Playwright per scenari utente completi
    \item \textbf{Load Testing}: Implementare test JMeter/Gatling per performance sistema sotto carico
    \item \textbf{Hardening Sicurezza}: Aggiungere HTTPS, autenticazione, autorizzazione (Spring Security)
    \item \textbf{Observability}: Aggiungere distributed tracing (Zipkin), metriche (Prometheus)
\end{enumerate}

\subsubsection{Ricerca Medio Termine}

\begin{enumerate}
    \item \textbf{Migrazione Microservizi}: Valutare impatto dependability della decomposizione monolite
    \item \textbf{Deployment Cloud}: Deploy su AWS/Azure/GCP e misurare affidabilità produzione
    \item \textbf{Chaos Engineering}: Introdurre failure controllati per testare resilienza
\end{enumerate}

\subsubsection{Ricerca Accademica Long-Term}

\begin{enumerate}
    \item \textbf{Studio Multi-Progetto}: Replicare analisi su 10+ progetti per generalizzabilità
    \item \textbf{Studio Longitudinale}: Monitorare evoluzione qualità su 12+ mesi
    \item \textbf{Comparazione Tool}: Confrontare sistematicamente tool mutation testing
    \item \textbf{Analisi Costo-Beneficio}: Quantificare ROI di ogni tecnica quality assurance
\end{enumerate}

\subsection{Raccomandazioni Pratiche}

Per practitioner che implementano analisi simili:

\subsubsection{Pratiche Essenziali}

\begin{enumerate}
    \item \textbf{Iniziare con CI/CD}: Quality gate automatici prevengono regressioni
    \item \textbf{Combinare Coverage + Mutation}: Entrambe le metriche essenziali per qualità test
    \item \textbf{Tool Sicurezza Multipli}: Tool diversi trovano vulnerabilità diverse
    \item \textbf{Escludere Codice Generato}: Focus mutation testing su business logic
    \item \textbf{Documentare Decisioni}: Rationale per scelte configurazione aiuta manutenzione futura
\end{enumerate}

\subsubsection{Strategia Adozione}

\begin{enumerate}
    \item \textbf{Fase 1}: Pipeline CI/CD con test base (Settimana 1)
    \item \textbf{Fase 2}: Aggiungere coverage (JaCoCo) e analisi statica (SonarCloud) (Settimana 2)
    \item \textbf{Fase 3}: Aggiungere mutation testing (PITest) e migliorare test (Settimana 3-4)
    \item \textbf{Fase 4}: Aggiungere security scanning (SpotBugs, OWASP DC) (Settimana 5)
    \item \textbf{Fase 5}: Aggiungere performance (JMH) e test generation (Randoop) (Settimana 6)
\end{enumerate}

\subsection{Contributo alla Conoscenza}

\subsubsection{Contributi Metodologici}

\begin{itemize}
    \item \textbf{Framework Integrato}: Dimostra sinergia di nove tool complementari
    \item \textbf{Rationale Esclusione Strategica}: Giustificazione accademica per escludere codice auto-generato
    \item \textbf{Protocollo Riproducibile}: Metodologia dettagliata abilita replicazione
\end{itemize}

\subsubsection{Contributi Pratici}

\begin{itemize}
    \item \textbf{Pattern Configurazione Tool}: Configurazioni provate per progetti Spring Boot
    \item \textbf{Template CI/CD}: Workflow GitHub Actions riusabili
    \item \textbf{Catalogo Best Practice}: Soluzioni documentate a sfide comuni
\end{itemize}

\subsection{Considerazioni Finali}

Questa analisi di dependability dimostra che l'applicazione sistematica di moderni tool e pratiche di ingegneria del software può raggiungere metriche di qualità eccezionali. Il 100\% mutation score, 91.9\% code coverage, zero vulnerabilità e rating Triple-A SonarCloud validano l'efficacia del nostro approccio multi-sfaccettato.

\textbf{Insight Chiave}: La dependability software non è una singola metrica ma una proprietà multi-dimensionale che richiede tecniche di analisi complementari. La sinergia di analisi statica (SonarCloud), analisi dinamica (JaCoCo), mutation testing (PITest), security scanning (SpotBugs, OWASP) e performance benchmarking (JMH) fornisce quality assurance completa.

\textbf{Decisione Critica}: Escludere il codice generato da Lombok dal mutation testing rappresenta un focus strategico sulla qualità della logica di business piuttosto che perseguire perfezione metrica fuorviante. Questa decisione si allinea con principi accademici e pratiche industriali.

\textbf{Impatto Pratico}: L'applicazione risultante è production-ready con quality gate automatici, test suite comprensiva, zero vulnerabilità note, deployment Docker ottimizzato e documentazione completa.

\textbf{Valore Accademico}: La metodologia, gli insight e le sfide documentate in questo report forniscono un blueprint per analisi simili su API REST Spring Boot, contribuendo alla comunità di ricerca e educazione dell'ingegneria del software.

Il percorso dallo stato iniziale (89 test, coverage sconosciuto, nessuno security scanning) allo stato finale (1.626 test, 100\% mutation score, zero vulnerabilità) dimostra il potere trasformativo dell'assicurazione qualità sistematica.

\vspace{1cm}

\noindent\textbf{Repository}: \url{https://github.com/sepping12/progetto_SwD}

\noindent\textbf{SonarCloud}: \url{https://sonarcloud.io/project/overview?id=sepping12_progetto_SwD}

\noindent\textbf{DockerHub}: \url{https://hub.docker.com/r/sepping12/progetto-swd}

\vspace{0.5cm}

\noindent\emph{Questa analisi rappresenta una valutazione di dependability completa dimostrando che una qualità software eccezionale è raggiungibile attraverso l'applicazione sistematica di tool moderni, configurazione attenta e miglioramento iterativo.}
