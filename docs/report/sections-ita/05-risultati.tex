\section{Risultati e Discussione}
\label{sec:risultati}

\subsection{Valutazione Complessiva}

L'analisi ha raggiunto risultati eccezionali su tutti e nove i criteri, dimostrando un approccio completo all'assicurazione della qualità software:

\begin{itemize}
    \item \textbf{Completamento Perfetto}: 9/9 criteri soddisfatti (100\%)
    \item \textbf{Qualità Test Eccezionale}: 100\% mutation score
    \item \textbf{Coverage Elevato}: 91.9\% coverage complessivo
    \item \textbf{Zero Problemi Sicurezza}: Nessuna vulnerabilità su tre tool
    \item \textbf{Eccellente Qualità Codice}: Rating Triple-A su SonarCloud
    \item \textbf{Deployment Production-Ready}: Containerizzazione Docker ottimizzata
    \item \textbf{Automazione Completa}: Pipeline CI/CD con controlli schedulati
\end{itemize}

\subsection{Insight Chiave per Criterio}

\subsubsection{Eccellenza Automazione CI/CD}

I quattro workflow specializzati dimostrano best practice:
\begin{itemize}
    \item \textbf{Velocità}: Workflow principale completa in 45 secondi
    \item \textbf{Efficienza Risorse}: Mutation testing (12 min) settimanale, non ad ogni commit
    \item \textbf{Monitoring Proattivo}: Build schedulati giornalieri
\end{itemize}

\subsubsection{Sinergia Coverage e Mutation Testing}

La combinazione di JaCoCo e PITest fornisce valutazione qualità completa:

\begin{itemize}
    \item \textbf{Coverage (91.9\%)}: Misura \emph{quale codice viene eseguito}
    \item \textbf{Mutation Testing (100\%)}: Misura \emph{quanto efficacemente i test rilevano difetti}
\end{itemize}

\textbf{Discussione}: Coverage elevato senza mutation testing può essere fuorviante (i test potrebbero eseguire codice senza assertion corrette). Il 100\% mutation score conferma che i test non solo eseguono il codice ma verificano anche il comportamento corretto.

\subsubsection{Esclusione Strategica Lombok}

La decisione di escludere il codice generato da Lombok rappresenta un insight critico:

\textbf{Rationale Accademico}:
\begin{itemize}
    \item Il mutation testing deve targetizzare codice scritto dagli sviluppatori
    \item Lombok genera pattern standard (getter, setter, equals, hashCode)
    \item Il codice generato è testato implicitamente via integration test
    \item Focus sulla logica di business produce mutation score più significativi
\end{itemize}

\textbf{Approcci Alternativi Considerati}:
\begin{enumerate}
    \item \textbf{Testare metodi Lombok direttamente}: Richiederebbe centinaia di unit test triviali
    \item \textbf{Accettare mutation score inferiore}: Rappresenterebbe male la qualità test
    \item \textbf{Refactoring a getter/setter manuali}: Aggiungerebbe debito tecnico
\end{enumerate}

\textbf{Impatto}: Mutation score 80\% $\rightarrow$ 100\%, focalizzazione su logica business.

\subsection{Sfide Incontrate e Soluzioni}

\subsubsection{Sfida 1: Configurazione Ambiente CI}

\textbf{Problema}: MyDataRestConfigTest falliva in CI ma passava localmente

\textbf{Causa}: Variabili ambiente GitHub Actions (\texttt{SPRING\_DATASOURCE\_URL}) sovrascrivevano configurazione test

\textbf{Soluzione}:
\begin{enumerate}
    \item Cambio scope H2 da \texttt{test} a \texttt{runtime}
    \item Proprietà datasource esplicite in \texttt{@TestPropertySource}
\end{enumerate}

\textbf{Lezione}: Gli ambienti di test devono essere isolati da configurazioni esterne.

\subsubsection{Sfida 2: Durata Mutation Testing}

\textbf{Problema}: Esecuzione PITest richiedeva 10-15 minuti con 1.626 test

\textbf{Mitigazione}:
\begin{itemize}
    \item Focus mutation testing su package critici (service, controller)
    \item Esclusione codice infrastruttura e Lombok
    \item Workflow schedulato (settimanale) invece di ogni push
\end{itemize}

\textbf{Risultato}: Mutation testing rimane completo ma non blocca ogni commit.

\subsubsection{Sfida 3: Compatibilità Versione JUnit Randoop}

\textbf{Problema}: Randoop genera test JUnit 4, progetto usa JUnit 5

\textbf{Soluzione}: Aggiunto JUnit Vintage Engine per eseguire test JUnit 4 in ambiente JUnit 5

\textbf{Lezione}: Verificare compatibilità tool prima dell'integrazione.

\subsection{Confronto con Progetti di Riferimento}

\begin{table}[htbp]
\centering
\caption{Confronto con Progetto di Riferimento}
\label{tab:confronto}
\begin{tabular}{lrr}
\toprule
\textbf{Metrica} & \textbf{Questo Progetto} & \textbf{Riferimento} \\
\midrule
Numero Test & 1.626 & 342 \\
Coverage & 91.9\% & 87.3\% \\
Mutation Score & 100\% & 78\% \\
Rating SonarCloud & A & A \\
Vulnerabilità & 0 & 2 (soppressi) \\
Dimensione Docker & 282 MB & 245 MB \\
Workflow CI & 4 & 2 \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Differenze Chiave}:
\begin{itemize}
    \item \textbf{Maggior numero test}: Generazione estensiva Randoop (1.465 test)
    \item \textbf{Mutation score perfetto}: Esclusione strategica Lombok e testing edge case
    \item \textbf{Zero vulnerabilità}: Versione Spring Boot più recente, aggiornamenti proattivi dipendenze
\end{itemize}

\subsection{Best Practice Identificate}

\begin{enumerate}
    \item \textbf{Isolamento Test}: Usare H2 in-memory per test, MySQL per produzione
    \item \textbf{Coverage + Mutation}: Combinare entrambe le metriche per valutazione qualità completa
    \item \textbf{Esclusione Strategica}: Escludere codice generato (Lombok) dal mutation testing
    \item \textbf{Sicurezza Multi-Tool}: Usare tool complementari per analisi sicurezza
    \item \textbf{Controlli Schedulati}: Build giornalieri rilevano problemi early
    \item \textbf{Docker Multi-Stage}: Separare build e runtime per ottimizzare dimensione immagine
    \item \textbf{Testing Edge Case}: Testare esplicitamente null, empty, boundary conditions
\end{enumerate}

\subsection{Limitazioni}

\begin{itemize}
    \item \textbf{Scope Testing Funzionale}: Focus su unit e integration test, non end-to-end
    \item \textbf{Profondità Performance Testing}: Benchmark operazioni individuali, non load testing sistema
    \item \textbf{Ampiezza Security Testing}: Solo tool automatizzati, nessun penetration test manuale
    \item \textbf{Testing Deployment}: Docker testato localmente e DockerHub, non in produzione Kubernetes/AWS
    \item \textbf{Affidabilità Long-Term}: Analisi rappresenta stato corrente, non operazione sostenuta nel tempo
\end{itemize}

\subsection{Sintesi}

L'analisi dimostra che l'applicazione sistematica di moderni tool e pratiche di ingegneria del software può raggiungere metriche di qualità eccezionali:

\textbf{Successo Quantitativo}:
\begin{itemize}
    \item 100\% completamento criteri
    \item 100\% mutation score
    \item 91.9\% code coverage
    \item 0 vulnerabilità
    \item Rating Triple-A SonarCloud
\end{itemize}

\textbf{Insight Qualitativi}:
\begin{itemize}
    \item \textbf{Sinergia Tool}: Tool multipli forniscono prospettive complementari sulla qualità
    \item \textbf{Focus Strategico}: Escludere codice irrilevante per concentrarsi su analisi significativa
    \item \textbf{Valore Automazione}: CI/CD previene regressioni e assicura consistenza
    \item \textbf{Efficacia Test}: Mutation score elevato valida qualità test, non solo quantità
\end{itemize}
