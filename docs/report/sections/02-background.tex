\section{Background}
\label{sec:background}

This chapter introduces the theoretical foundation and technical context for the dependability analysis, covering software dependability concepts and the tools employed in this study.

\subsection{Software Dependability}

Software dependability is a comprehensive concept encompassing the trustworthiness of a computing system, defined by its ability to deliver service that can justifiably be trusted. The concept integrates several quality attributes~\cite{software-testing-craft}:

\begin{description}
    \item[Reliability] The probability that a system will perform its intended function without failure over a specified period
    \item[Availability] The proportion of time a system is operational and accessible
    \item[Safety] The absence of catastrophic consequences to users and environment
    \item[Security] The protection against intentional unauthorized access or manipulation
    \item[Maintainability] The ease with which a system can be modified to correct defects or adapt to changes
    \item[Testability] The degree to which a system facilitates the establishment of test criteria
\end{description}

\subsection{Code Quality Metrics}

Modern software development relies on quantifiable metrics to assess code quality:

\subsubsection{Static Analysis Metrics}

Static analysis examines source code without execution~\cite{sonarcloud}:

\begin{itemize}
    \item \textbf{Cyclomatic Complexity}: Measures the number of linearly independent paths through code
    \item \textbf{Code Smells}: Indicators of potential design problems
    \item \textbf{Technical Debt}: Estimated time to fix all maintainability issues
    \item \textbf{Duplication}: Percentage of duplicated code blocks
\end{itemize}

\subsubsection{Dynamic Analysis Metrics}

Dynamic analysis evaluates running code~\cite{jacoco}:

\begin{itemize}
    \item \textbf{Line Coverage}: Percentage of executable lines executed by tests
    \item \textbf{Branch Coverage}: Percentage of decision branches taken during test execution
    \item \textbf{Method Coverage}: Percentage of methods invoked by tests
    \item \textbf{Instruction Coverage}: Percentage of bytecode instructions executed
\end{itemize}

\subsection{Mutation Testing}

Mutation testing evaluates test suite quality by introducing controlled defects (mutations) into the code~\cite{mutation-testing-survey}. Each mutation represents a potential bug:

\begin{equation}
\text{Mutation Score} = \frac{\text{Killed Mutants}}{\text{Total Mutants} - \text{Equivalent Mutants}} \times 100\%
\end{equation}

\subsubsection{Mutation Operators}

Common mutation operators include:

\begin{itemize}
    \item \textbf{Conditionals Boundary}: Changes \texttt{<} to \texttt{<=}, \texttt{>} to \texttt{>=}
    \item \textbf{Negate Conditionals}: Inverts boolean conditions (\texttt{==} to \texttt{!=})
    \item \textbf{Math Mutator}: Changes arithmetic operators (\texttt{+} to \texttt{-}, \texttt{*} to \texttt{/})
    \item \textbf{Return Values}: Modifies return values (e.g., 0 to 1, true to false)
    \item \textbf{Void Method Calls}: Removes method calls with void return type
\end{itemize}

\subsubsection{Mutation Testing Interpretation}

\begin{table}[htbp]
\centering
\caption{Mutation Score Interpretation Guidelines}
\label{tab:mutation-interpretation}
\begin{tabular}{ll}
\toprule
\textbf{Score Range} & \textbf{Interpretation} \\
\midrule
> 80\% & Excellent - Highly effective test suite \\
60--80\% & Good - Adequate testing with improvement opportunities \\
40--60\% & Sufficient - Basic testing with significant gaps \\
< 40\% & Insufficient - Weak test suite requiring major enhancements \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Analysis Tools}

\subsubsection{SonarCloud}

SonarCloud is a cloud-based static code analysis platform providing comprehensive quality metrics~\cite{sonarcloud}:

\begin{itemize}
    \item \textbf{Quality Gates}: Configurable thresholds for passing builds
    \item \textbf{Security Hotspots}: Identification of security-sensitive code
    \item \textbf{OWASP Top 10}: Detection of common web vulnerabilities
    \item \textbf{Technical Debt}: Estimation of remediation effort
    \item \textbf{Code Smells}: Detection of maintainability issues
\end{itemize}

\textbf{Rating System}: SonarCloud uses A-E ratings:
\begin{itemize}
    \item \textbf{A}: 0 issues (excellent)
    \item \textbf{B}: 1--10 issues (good)
    \item \textbf{C}: 11--50 issues (acceptable)
    \item \textbf{D}: 51--100 issues (needs attention)
    \item \textbf{E}: > 100 issues (critical)
\end{itemize}

\subsubsection{JaCoCo}

JaCoCo (Java Code Coverage) is a free code coverage library for Java~\cite{jacoco}. It instruments bytecode at runtime to measure:

\begin{itemize}
    \item Line and branch coverage
    \item Method and class coverage
    \item Cyclomatic complexity per method
    \item Coverage reports in HTML, XML, and CSV formats
\end{itemize}

\subsubsection{PITest}

PITest is a state-of-the-art mutation testing system for Java~\cite{pitest}. Key features:

\begin{itemize}
    \item Fast execution using bytecode manipulation
    \item Parallel execution support
    \item Integration with Maven and Gradle
    \item Support for JUnit 4, JUnit 5, and TestNG
    \item Configurable mutation operators
    \item HTML and XML report generation
\end{itemize}

\subsubsection{JMH (Java Microbenchmark Harness)}

JMH is the de-facto standard for Java performance benchmarking~\cite{jmh}:

\begin{itemize}
    \item \textbf{Warmup Iterations}: JVM optimization stabilization
    \item \textbf{Fork Isolation}: Separate JVM instances per benchmark
    \item \textbf{Blackhole}: Prevents dead code elimination
    \item \textbf{Statistical Analysis}: Mean, median, percentiles
    \item \textbf{Profilers}: Integration with JFR, async-profiler
\end{itemize}

\subsubsection{Randoop}

Randoop is an automatic test generator for Java~\cite{randoop}:

\begin{itemize}
    \item \textbf{Feedback-Directed}: Uses runtime behavior to guide generation
    \item \textbf{Random Testing}: Explores program behavior through random inputs
    \item \textbf{Regression Tests}: Captures current behavior
    \item \textbf{Error-Revealing Tests}: Detects contract violations
\end{itemize}

\subsubsection{SpotBugs and FindSecBugs}

SpotBugs detects potential bugs in Java programs through static analysis~\cite{spotbugs}:

\begin{itemize}
    \item \textbf{Bug Categories}: Correctness, bad practice, performance, security
    \item \textbf{FindSecBugs Plugin}: Security-focused detection~\cite{findsecbugs}
    \item \textbf{OWASP Integration}: Alignment with OWASP Top 10
    \item \textbf{Confidence Levels}: High, medium, low priority bugs
\end{itemize}

\subsubsection{OWASP Dependency-Check}

OWASP Dependency-Check identifies known vulnerabilities in project dependencies~\cite{owasp-dc}:

\begin{itemize}
    \item \textbf{NVD Integration}: National Vulnerability Database
    \item \textbf{CVE Detection}: Common Vulnerabilities and Exposures
    \item \textbf{CVSS Scoring}: Common Vulnerability Scoring System
    \item \textbf{Suppression Management}: False positive handling
\end{itemize}

\subsection{Containerization and CI/CD}

\subsubsection{Docker}

Docker enables application containerization~\cite{docker}:

\begin{itemize}
    \item \textbf{Multi-stage Builds}: Optimization for production images
    \item \textbf{Layer Caching}: Faster build times
    \item \textbf{Health Checks}: Container health monitoring
    \item \textbf{Image Registry}: DockerHub for distribution
\end{itemize}

\subsubsection{GitHub Actions}

GitHub Actions provides CI/CD automation~\cite{github-actions}:

\begin{itemize}
    \item \textbf{Workflow Triggers}: Push, pull request, schedule
    \item \textbf{Matrix Builds}: Multiple configurations in parallel
    \item \textbf{Artifacts}: Build output preservation
    \item \textbf{Third-party Actions}: Extensive marketplace
\end{itemize}

\subsection{Spring Boot Framework}

Spring Boot simplifies Spring application development~\cite{spring-boot}:

\begin{itemize}
    \item \textbf{Convention over Configuration}: Sensible defaults
    \item \textbf{Embedded Servers}: Tomcat, Jetty, Undertow
    \item \textbf{Starter Dependencies}: Curated dependency sets
    \item \textbf{Auto-configuration}: Automatic bean configuration
    \item \textbf{Actuator}: Production-ready monitoring endpoints
\end{itemize}

\subsection{Project Lombok}

Project Lombok reduces Java boilerplate code through annotations~\cite{lombok-evaluation}:

\begin{itemize}
    \item \textbf{@Data}: Generates getters, setters, equals, hashCode, toString
    \item \textbf{@Builder}: Implements builder pattern
    \item \textbf{@NoArgsConstructor}: Generates no-argument constructor
    \item \textbf{@AllArgsConstructor}: Generates all-arguments constructor
\end{itemize}

\textbf{Mutation Testing Consideration}: Lombok-generated methods (equals, hashCode, toString) are framework-generated code. Testing these provides limited value compared to testing business logic. This project strategically excludes Lombok methods from mutation testing to focus on meaningful code quality metrics.
